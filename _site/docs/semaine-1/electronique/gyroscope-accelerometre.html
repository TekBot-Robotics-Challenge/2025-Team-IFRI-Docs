<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Tekbot Robotics Challenge 2025 | Documentation Ã‰quipe IFRI 2025</title>
  <link rel="stylesheet" href="/assets/css/style.css?v=cdc1b0436d736b495ca2b9304c6e98e6e1ac241a">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
</head>
<body>
  <!-- Header en dehors de la structure sidebar/main-content -->
  <header class="site-header">
    <div class="header">
  <div class="header-title">
    <h1>Tekbot Robotics Challenge 2025</h1>
  </div>
  <div class="header-actions">
    <div class="header-search">
      <input type="text" class="search-bar" placeholder="Rechercher..." id="searchInput">
    </div>
    <div class="header-theme-toggle">
      <button id="themeToggle" aria-label="Changer de thÃ¨me">ğŸŒ™</button>
    </div>
  </div>
</div>

  </header>

  <div class="page-wrapper">
    <div class="sidebar">
  <div class="sidebar-header">
    <img src="/media/image.png" alt="Logo" class="logo">
    <h2>TRC 2025</h2>
  </div>
  
  <ul class="sidebar-nav">
    <!-- Accueil -->
    <div class="nav-section">
      <div class="nav-section-title">
        <i class="fas fa-home"></i> ACCUEIL
      </div>
      <ul class="nav-items">
        <li class="nav-item ">
          <a href="/">Introduction</a>
        </li>
        <li class="nav-item ">
          <a href="/accueil">PrÃ©sentation dÃ©taillÃ©e</a>
        </li>
      </ul>
    </div>
    
    <!-- Semaine 1 -->
    <div class="nav-section">
      <div class="nav-section-title">
        <i class="fas fa-calendar-week"></i> SEMAINE 1
      </div>
      <ul class="nav-items">
        <li class="nav-item ">
          <a href="/docs/semaine-1/presentation">PrÃ©sentation</a>
        </li>
        <li class="nav-item ">
          <a href="/docs/semaine-1/electronique/README">Ã‰lectronique: Gyroscope</a>
        </li>
        <li class="nav-item ">
          <a href="/docs/semaine-1/it/robot">IT: Gestion Robot</a>
        </li>
        <li class="nav-item ">
          <a href="/docs/semaine-1/mecanique/documentation_meca">MÃ©canique: Conception</a>
        </li>
      </ul>
    </div>
    
    <!-- Semaine 2 -->
    <div class="nav-section">
      <div class="nav-section-title">
        <i class="fas fa-calendar-week"></i> SEMAINE 2
      </div>
      <ul class="nav-items">
        <li class="nav-item ">
          <a href="/docs/semaine-2/presentation">PrÃ©sentation</a>
        </li>
        <li class="nav-item ">
          <a href="/docs/semaine-2/electronique">Ã‰lectronique: BoÃ®te noire</a>
        </li>
        <li class="nav-item ">
          <a href="/docs/semaine-2/it">IT: ROS2</a>
        </li>
        <li class="nav-item ">
          <a href="/docs/semaine-2/mecanique">MÃ©canique: IntermÃ©diaire</a>
        </li>
      </ul>
    </div>
    
    <!-- Semaine 3 -->
    <div class="nav-section">
      <div class="nav-section-title">
        <i class="fas fa-calendar-week"></i> SEMAINE 3
      </div>
      <ul class="nav-items">
        <li class="nav-item ">
          <a href="/docs/semaine-3/presentation">PrÃ©sentation</a>
        </li>
        <li class="nav-item ">
          <a href="/docs/semaine-3/electronique">Ã‰lectronique: Afficheur</a>
        </li>
        <li class="nav-item ">
          <a href="/docs/semaine-3/it">IT: Pathfinding</a>
        </li>
        <li class="nav-item ">
          <a href="/docs/semaine-3/mecanique">MÃ©canique: AvancÃ©</a>
        </li>
      </ul>
    </div>
    
    <!-- Test Final -->
    <div class="nav-section">
      <div class="nav-section-title">
        <i class="fas fa-trophy"></i> TEST FINAL
      </div>
      <ul class="nav-items">
        <li class="nav-item ">
          <a href="/docs/test-final/presentation">PrÃ©sentation</a>
        </li>
        <li class="nav-item ">
          <a href="/docs/test-final/guide-test-final">Guide du test final</a>
        </li>
      </ul>
    </div>
  </ul>
</div>


    
    <div class="main-content">
      <div class="markdown-content">
        <h1 id="tekbot-robotics-challenge-2025">Tekbot Robotics Challenge 2025</h1>

<h2 id="test-1--gyroscope--accÃ©lÃ©romÃ¨tre-mpu-6050---gestion-durable-des-dÃ©chets--Ã©preuve-Ã©lectronique">Test 1 : Gyroscope &amp; AccÃ©lÃ©romÃ¨tre (MPU-6050) - Gestion Durable des DÃ©chets â€“ Ã‰preuve Ã‰lectronique</h2>

<p><strong>Ã‰quipe IFRI Ã‰lectronique :</strong></p>
<ul>
  <li>Aretha FAGLA</li>
  <li>Hugues ANTAN</li>
  <li>Marielle AGBOSSOUNON</li>
  <li>Eunice ODJO</li>
  <li>Livingstone GBOZO</li>
</ul>

<p><strong>Institution :</strong> Institut de Formation et de Recherche en Informatique (IFRI), UniversitÃ© dâ€™Abomey-Calavi
<strong>Date :</strong> 12 Juin 2025</p>

<hr />

<h2 id="table-des-matiÃ¨res">Table des matiÃ¨res</h2>

<ul>
  <li><a href="#1-introduction-et-objectifs">Introduction et Objectifs</a></li>
  <li><a href="#2-matÃ©riel-et-branchements">MatÃ©riel et branchements</a></li>
  <li><a href="#3-principe-de-fonctionnement-du-mpu-6050">Principe de fonctionnement du MPU-6050</a></li>
  <li><a href="#4-architecture-du-systÃ¨me">Architecture du systÃ¨me</a></li>
  <li><a href="#5-schÃ©ma-Ã©lectrique-kicad">SchÃ©ma Ã©lectrique (KiCad)</a></li>
  <li><a href="#6-installation-et-compilation-du-code">Installation et compilation du code</a></li>
  <li><a href="#7-explication-dÃ©taillÃ©e-du-code">Explication dÃ©taillÃ©e du code</a></li>
  <li><a href="#8-mode-demploi-et-dÃ©monstration">Mode dâ€™emploi et dÃ©monstration</a></li>
  <li><a href="#9-rÃ©sultats-attendus">RÃ©sultats attendus</a></li>
  <li><a href="#10-conseils-de-rÃ©glage-et-calibration">Conseils de rÃ©glage et calibration</a></li>
  <li><a href="#11-limitations-et-pistes-damÃ©lioration">Limitations et pistes dâ€™amÃ©lioration</a></li>
  <li><a href="#12-rÃ©fÃ©rences-et-annexes">RÃ©fÃ©rences et annexes</a></li>
</ul>

<hr />

<h1 id="1-introduction-et-objectifs">1. Introduction et Objectifs</h1>

<h2 id="11-contexte">1.1 Contexte</h2>

<p>Le TEKBOT Robotics Challenge 2025 est une compÃ©tition internationale annuelle, organisÃ©e par TEKBOT Robotics (startup DeepTech basÃ©e au BÃ©nin), qui met en compÃ©tition de jeunes talents africains autour de dÃ©fis robotiques et dâ€™IA. Le thÃ¨me 2025, Â« RÃ©silience Urbaine : Gestion Durable des DÃ©chets Â», propose de concevoir des robots autonomes capables de collecter, trier et distribuer des dÃ©chets dans une simulation de ville fictive, EcoCity. Dans le cadre de la prÃ©sÃ©lection, Test 1 Ã©value vos compÃ©tences en Ã©lectronique et capteurs. Lâ€™objectif est de dÃ©montrer notre maÃ®trise du MPU-6050 (capteur 6 axes â€“ accÃ©lÃ©romÃ¨tre + gyroscope) en mesurant et en affichant :</p>

<ul>
  <li>Lâ€™orientation du mouvement (gauche, droite, haut, bas, stable)</li>
  <li>La vitesse du mouvement</li>
  <li>La restitution sur Ã©cran (LCD 16Ã—2, en temps rÃ©el)</li>
</ul>

<h2 id="12-objectifs-dÃ©taillÃ©s">1.2 Objectifs dÃ©taillÃ©s</h2>

<ul>
  <li>Mettre en Å“uvre la communication I2C pour lire en temps rÃ©el les registres du MPU-6050.</li>
  <li>Calibrer le capteur (mesure du biais du gyroscope et de la rÃ©fÃ©rence de lâ€™accÃ©lÃ©romÃ¨tre).</li>
  <li>Traiter les donnÃ©es brutes :
    <ul>
      <li>Conversion LSB â†’ unitÃ©s rÃ©elles (g, Â°/s, m/sÂ²),</li>
      <li>Filtrage (Digital Low Pass Filter) et fusion capteurs (filtre complÃ©mentaire).</li>
    </ul>
  </li>
  <li>Affichant, conformÃ©ment Ã  lâ€™Ã©noncÃ© du test :
    <ul>
      <li>Orientation statique (haut, bas, gauche, droite, stable),</li>
      <li>Vitesse dâ€™accÃ©lÃ©ration (en m/sÂ²) sur un Ã©cran LCD 16Ã—2.</li>
    </ul>
  </li>
  <li>En nous plongeant dans un contexte rÃ©el de vol, nous avons Ã©tendu la dÃ©tection Ã  plusieurs types de mouvements dynamiques dÃ©taillant mieux quels types de mouvement Ã  gauche, Ã  droite, vers le haut ou le bas :
    <ul>
      <li>MontÃ©e / descente,</li>
      <li>Virage gauche / virage droite,</li>
      <li>Glissement avant / glissement arriÃ¨re,</li>
      <li>Glissement latÃ©ral,</li>
      <li>Vol stable.</li>
    </ul>
  </li>
  <li>Mesurer le Jerk (variation dâ€™accÃ©lÃ©ration) pour qualifier la Â« brutalitÃ© Â» des manÅ“uvres.</li>
  <li>Afficher les rÃ©sultats de maniÃ¨re claire et intuitive sur un Ã©cran LCD 16Ã—2.</li>
  <li>Documenter lâ€™ensemble du projet (schÃ©ma, code, explications) de faÃ§on Ã  rendre la solution comprÃ©hensible, pÃ©renne et partageable sur GitHub.</li>
</ul>

<hr />

<h1 id="2-matÃ©riel-et-branchements">2. MatÃ©riel et branchements</h1>

<h2 id="21-composants-Ã©lectroniques">2.1 Composants Ã©lectroniques</h2>

<h3 id="arduino-uno">Arduino Uno:</h3>
<ul>
  <li><strong>Description:</strong> MicrocontrÃ´leur ATmega328P, 14 GPIO, 6 entrÃ©es analogiques.</li>
  <li><strong>RÃ´le dans le montage:</strong> CÅ“ur du systÃ¨me : il lit le capteur, exÃ©cute le code et pilote lâ€™Ã©cran.</li>
  <li><strong>Image:</strong>
    <ul>
      <li>Img 1 : Arduino Uno
  <img src="/docs/semaine-1/electronique/images/Arduino_Uno_-_R3.jpg" alt="Arduino Uno" /></li>
    </ul>
  </li>
</ul>

<h3 id="mpu-6050">MPU-6050:</h3>
<ul>
  <li><strong>Description:</strong> Module IÂ²C combinant un accÃ©lÃ©romÃ¨tre 3 axes Â±2 g et un gyroscope 3 axes Â±250 Â°/s.</li>
  <li><strong>RÃ´le dans le montage:</strong> Mesure lâ€™orientation et lâ€™accÃ©lÃ©ration.</li>
  <li><strong>Image:</strong>
    <ul>
      <li>Img 2 : MPU-6050
  <img src="/docs/semaine-1/electronique/images/MPU6050.jpg" alt="MPU6050" /></li>
    </ul>
  </li>
</ul>

<h3 id="Ã©cran-lcd-hd44780-162">Ã‰cran LCD HD44780 16Ã—2:</h3>
<ul>
  <li><strong>Description:</strong> Afficheur alphanumÃ©rique 16 colonnes Ã— 2 lignes en mode 4 bits.</li>
  <li><strong>RÃ´le dans le montage:</strong> PrÃ©sente en temps rÃ©el lâ€™orientation et lâ€™intensitÃ© du mouvement.</li>
  <li><strong>Image:</strong>
    <ul>
      <li>Img 3 : Ecran LCD
  <img src="/docs/semaine-1/electronique/images/LCD_Screen.jpg" alt="Ecran LCD" /></li>
    </ul>
  </li>
</ul>

<h3 id="potentiomÃ¨tre-10kÏ‰">PotentiomÃ¨tre 10kÎ©:</h3>
<ul>
  <li><strong>Description:</strong> RÃ©sistance variable linÃ©aire.</li>
  <li><strong>RÃ´le dans le montage:</strong> Permet dâ€™ajuster le contraste de lâ€™Ã©cran LCD.</li>
  <li><strong>Image:</strong>
    <ul>
      <li>Img 4 : PotentiomÃ¨tre
  <img src="/docs/semaine-1/electronique/images/Pot_10K.jpg" alt="PotentiomÃ¨tre 10kÎ©" /></li>
    </ul>
  </li>
</ul>

<h3 id="pile-rechargeable-9v">Pile rechargeable 9V:</h3>
<ul>
  <li><strong>Description:</strong> Source de tension.</li>
  <li><strong>RÃ´le dans le montage:</strong> Fournit une alimentation stable Ã  lâ€™Arduino, au module et Ã  lâ€™Ã©cran.</li>
  <li><strong>Image:</strong>
    <ul>
      <li>Img 5 : Pile 9V rechargeable
  <img src="/docs/semaine-1/electronique/images/Pile_9v.jpg" alt="Pile 9V" /></li>
    </ul>
  </li>
</ul>

<h3 id="breadboard--fils-dupont">Breadboard + fils Dupont:</h3>
<ul>
  <li><strong>Description:</strong> Plaque dâ€™essai sans soudure et cÃ¢bles colorÃ©s.</li>
  <li><strong>RÃ´le dans le montage:</strong> Montage rapide, structurÃ© et rÃ©utilisable.</li>
  <li><strong>Images:</strong>
    <ul>
      <li>Img 6 : Breadboard
  <img src="/docs/semaine-1/electronique/images/breadboard.jpeg" alt="Breadboard" /></li>
      <li>Img 7 : Fils Dupont
  <img src="/docs/semaine-1/electronique/images/dupont_connectors.avif" alt="Fils Dupont (Jumpers)" /></li>
    </ul>
  </li>
</ul>

<h2 id="22-outils-logiciels">2.2 Outils Logiciels</h2>

<h3 id="arduino-ide">Arduino IDE</h3>
<ul>
  <li><strong>Description:</strong> Environnement de programmation officiel pour cartes Arduino. C/C++ simplifiÃ©, moniteur sÃ©rie intÃ©grÃ©.</li>
  <li><strong>Lien de tÃ©lÃ©chargement/Documentation:</strong> https://www.arduino.cc/en/software</li>
  <li><strong>Image:</strong>
    <ul>
      <li>Img 8 : Logo/Image Arduino IDE
  <img src="/docs/semaine-1/electronique/images/Arduino-IDE-Interface.png" alt="Arduino IDE" /></li>
    </ul>
  </li>
</ul>

<h3 id="i2cdevlib--mpu6050">I2Cdevlib / MPU6050</h3>
<ul>
  <li><strong>Description:</strong> BibliothÃ¨que Arduino pour communiquer facilement avec le MPU-6050, inclut fonctions de calibration et DMP.</li>
  <li><strong>Lien de tÃ©lÃ©chargement/Documentation:</strong> https://github.com/jrowberg/i2cdevlib</li>
</ul>

<h3 id="liquidcrystal">LiquidCrystal</h3>
<ul>
  <li><strong>Description:</strong> BibliothÃ¨que Arduino embarquÃ©e pour piloter les Ã©crans HD44780 en mode 4 bits.</li>
  <li><strong>Lien de tÃ©lÃ©chargement/Documentation:</strong> Inclus dans lâ€™IDE</li>
</ul>

<h3 id="kicad">KiCad</h3>
<ul>
  <li><strong>Description:</strong> Suite open-source pour la crÃ©ation de schÃ©mas Ã©lectroniques et de layouts de circuits imprimÃ©s.</li>
  <li><strong>Lien de tÃ©lÃ©chargement/Documentation:</strong> https://kicad.org/download/</li>
</ul>

<h3 id="git--github">Git / GitHub</h3>
<ul>
  <li><strong>Description:</strong> Outils de versionning et dâ€™hÃ©bergement de code.</li>
  <li><strong>Lien de tÃ©lÃ©chargement/Documentation:</strong> https://git-scm.com/ / https://github.com</li>
</ul>

<h2 id="23-schÃ©ma-de-connexion">2.3 SchÃ©ma de connexion</h2>

<h3 id="231-mpu-6050--arduino">2.3.1 MPU-6050 â†” Arduino</h3>

<table>
  <thead>
    <tr>
      <th>Broche MPU-6050</th>
      <th>Broche Arduino</th>
      <th>Fonction</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>VDD</td>
      <td>5V</td>
      <td>Alimentation +5 V</td>
    </tr>
    <tr>
      <td>GND</td>
      <td>GND</td>
      <td>Masse</td>
    </tr>
    <tr>
      <td>SDA</td>
      <td>A4 (SDA)</td>
      <td>DonnÃ©es IÂ²C</td>
    </tr>
    <tr>
      <td>SCL</td>
      <td>A5 (SCL)</td>
      <td>Horloge IÂ²C</td>
    </tr>
    <tr>
      <td>(AD0)</td>
      <td>GND</td>
      <td>Adresse IÂ²C = 0x68</td>
    </tr>
  </tbody>
</table>

<h3 id="232-Ã©cran-lcd-16x2--arduino">2.3.2 Ã‰cran LCD 16x2 â†” Arduino</h3>

<table>
  <thead>
    <tr>
      <th>Broche LCD</th>
      <th>Fonction</th>
      <th>Broche Arduino</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>VSS</td>
      <td>Masse</td>
      <td>GND</td>
    </tr>
    <tr>
      <td>VDD</td>
      <td>Alimentation +5V</td>
      <td>5V</td>
    </tr>
    <tr>
      <td>V0</td>
      <td>Contraste</td>
      <td>Curseur de pot.</td>
    </tr>
    <tr>
      <td>RS</td>
      <td>Register Select</td>
      <td>D12</td>
    </tr>
    <tr>
      <td>E</td>
      <td>Enable</td>
      <td>D11</td>
    </tr>
    <tr>
      <td>D4</td>
      <td>Data bit 4</td>
      <td>D5</td>
    </tr>
    <tr>
      <td>D5</td>
      <td>Data bit 5</td>
      <td>D4</td>
    </tr>
    <tr>
      <td>D6</td>
      <td>Data bit 6</td>
      <td>D3</td>
    </tr>
    <tr>
      <td>D7</td>
      <td>Data bit 7</td>
      <td>D2</td>
    </tr>
    <tr>
      <td>RW</td>
      <td>Read/Write (Ã  0 pour Ã©criture)</td>
      <td>GND</td>
    </tr>
  </tbody>
</table>

<h3 id="233-alimentation">2.3.3 Alimentation</h3>

<p>| Ã‰lÃ©ment         | Connexion                     | Remarque                                 |
|â€”â€”â€”â€”â€”â€“|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”|
| Pile 9V         | EntrÃ©e de lâ€™Arduino (barrel jack)           | 9V                                       |
|                 | Masse â†’ GND rail              |                                          |
â€”</p>

<h1 id="3-principe-de-fonctionnement-du-mpu-6050">3. Principe de fonctionnement du MPU-6050</h1>

<p>Le MPU-6050 est un tout-en-un trÃ¨s utilisÃ© dans les projets embarquÃ©s : câ€™est un module qui combine un accÃ©lÃ©romÃ¨tre 3 axes et un gyroscope 3 axes, le tout pilotÃ© par un microcontrÃ´leur interne, le Digital Motion Processor (DMP). GrÃ¢ce Ã  ce DMP, on peut mÃªme dÃ©lÃ©guer certaines opÃ©rations de fusion de donnÃ©es au module lui-mÃªme, mais ici nous utiliserons les fonctions de base.</p>

<h2 id="31-accÃ©lÃ©romÃ¨tre">3.1 AccÃ©lÃ©romÃ¨tre</h2>

<p>Imaginons une sorte de petit â€œpÃ¨se-personneâ€ miniature intÃ©grÃ© dans le capteur : il mesure la force dâ€™accÃ©lÃ©ration exercÃ©e sur lui suivant trois directions :</p>
<ul>
  <li>Axe X : avant-arriÃ¨re</li>
  <li>Axe Y : gauche-droite</li>
  <li>Axe Z : haut-bas</li>
</ul>

<p>Quand lâ€™objet est immobile et Ã  plat, lâ€™axe vertical (Z) â€œvoitâ€ ou est soumis Ã  la gravitÃ©, soit +1 g (â‰ˆ 9,81 m/sÂ²). Si nous inclinons le capteur, la valeur sur X ou Y varie en fonction de lâ€™angle, nous donnant un moyen de calculer lâ€™inclinaison (tilt).</p>

<p>Lâ€™accÃ©lÃ©romÃ¨tre du MPU-6050 peut Ãªtre configurÃ© pour mesurer jusquâ€™Ã  Â±2 g, Â±4 g, Â±8 g ou Â±16 g, ce qui modifie sa rÃ©solution (le nombre de â€œpasâ€ numÃ©riques par g). Pour notre usage, la plage Â±2 g est idÃ©ale : elle offre la plus haute rÃ©solution (16 384 LSB pour 1 g).</p>

<h2 id="32-gyroscope">3.2 Gyroscope</h2>

<p>Un gyroscope MEMS est un capteur qui mesure la vitesse de rotation autour de trois axes :</p>
<ul>
  <li>Rotation autour de X (roulis)</li>
  <li>Rotation autour de Y (tangage)</li>
  <li>Rotation autour de Z (lacet)</li>
</ul>

<p>ConcrÃ¨tement, quand le capteur tourne, une structure vibrante Ã  lâ€™intÃ©rieur subit une force de Coriolis qui gÃ©nÃ¨re une tension proportionnelle Ã  la vitesse angulaire. Le MPU-6050 peut mesurer jusquâ€™Ã  Â±250 Â°/s, Â±500, Â±1000 ou Â±2000 Â°/s ; nous choisissons Â±250 Â°/s pour maximiser la prÃ©cision (131 LSB pour 1 Â°/s).</p>

<h2 id="33-registre-et-communication-i2c">3.3 Registre et communication I2C</h2>

<p>Le MPU-6050 communique avec lâ€™Arduino via IÂ²C, un bus de donnÃ©es Ã  deux fils (SDA pour les donnÃ©es, SCL pour lâ€™horloge), munis de rÃ©sistances de â€œpull-upâ€ pour rester Ã  lâ€™Ã©tat haut quand personne nâ€™Ã©met. Son adresse IÂ²C standard est 0x68 (ou 0x69 si on tire la broche AD0 Ã  +V).</p>

<p>Pour lire une mesure, lâ€™Arduino envoie dâ€™abord un â€œSTARTâ€ puis lâ€™adresse du capteur et le numÃ©ro du registre de dÃ©part (par exemple ACCEL_XOUT_H pour lâ€™accÃ©lÃ©ration X). Le capteur renvoie alors sÃ©quentiellement les octets suivants:</p>
<ul>
  <li>Valeur brute de lâ€™accÃ©lÃ©ration X (high byte, low byte)</li>
  <li>Valeur brute de lâ€™accÃ©lÃ©ration Y</li>
  <li>AccÃ©lÃ©ration Z</li>
  <li>Vitesse angulaire X, Y, Z</li>
</ul>

<p>Ces valeurs sont codÃ©es sur 16 bits signÃ©s (â€“32 768 Ã  +32 767). La bibliothÃ¨que I2Cdevlib et son pilote MPU6050 nous simplifient cette Ã©tape en fournissant directement la fonction <code class="language-plaintext highlighter-rouge">getMotion6()</code>, qui lit tout en une transaction.</p>

<h2 id="34-conversion-des-donnÃ©es-brutes">3.4 Conversion des donnÃ©es brutes</h2>

<p>Une fois que le module nous donne ces six valeurs entiÃ¨res, il faut les convertir en unitÃ©s physiques:</p>
<ul>
  <li><strong>AccÃ©lÃ©ration en g :</strong>
    <ul>
      <li>$a_g = \text{(Valeur brute)} / (\text{LSB/g})$</li>
      <li>Puis en m/sÂ² : $a_{m/s^2} = a_g \times 9.81$</li>
    </ul>
  </li>
  <li><strong>Vitesse angulaire en Â°/s :</strong>
    <ul>
      <li>$\omega_{Â°/s} = \text{(Valeur brute)} / \text{LSB/(Â°/s)}$</li>
    </ul>
  </li>
</ul>

<p>Ces conversions nous donnent des nombres directement exploitables pour savoir, par exemple, que lâ€™objet tourne Ã  45 Â°/s autour de lâ€™axe Z, ou subit une accÃ©lÃ©ration de 3 m/sÂ² vers la droite.</p>

<h2 id="35-filtrage-et-fusion">3.5 Filtrage et fusion</h2>

<p>Brut, le capteur gÃ©nÃ¨re souvent du bruit : petites fluctuations alÃ©atoires qui peuvent rendre lâ€™affichage instable. Le MPU-6050 intÃ¨gre un filtre passe-bas numÃ©rique (DLPF) que lâ€™on rÃ¨gle (par ex. Ã  20 Hz ou 42 Hz) pour attÃ©nuer les hautes frÃ©quences.</p>

<p>En outre, on combine lâ€™accÃ©lÃ©romÃ¨tre et le gyroscope avec un filtre complÃ©mentaire:</p>
<ul>
  <li>On intÃ¨gre la vitesse angulaire pour obtenir un angle Ã  court terme.</li>
  <li>On calcule lâ€™angle â€œstatiqueâ€ depuis lâ€™accÃ©lÃ©romÃ¨tre pour la stabilitÃ© long terme.</li>
  <li>On mÃ©lange les deux :
    <ul>
      <li>$\theta = \alpha(\theta + \omega\Delta t) + (1-\alpha)\theta_{acc}$</li>
      <li>avec $\alpha \approx 0,94$.</li>
    </ul>
  </li>
</ul>

<p>Le rÃ©sultat est un angle Ã  la fois rÃ©actif et stable, idÃ©al pour dÃ©tecter le roulis ou le tangage de notre maquette dâ€™avion.</p>

<hr />

<h1 id="4-architecture-du-systÃ¨me">4. Architecture du systÃ¨me</h1>

<p>Avant de plonger dans le code, visualisons comment chaque Ã©lÃ©ment matÃ©riel et logiciel interagit pour transformer des vibrations et des rotations en un affichage clair.</p>

<h2 id="41-alimentation">4.1 Alimentation</h2>

<p>Une pile rechargeable 9 V alimente le circuit.</p>
<ul>
  <li>Lâ€™Arduino Uno</li>
  <li>Le module MPU-6050</li>
  <li>Lâ€™Ã©cran LCD 16Ã—2</li>
</ul>

<p>Toutes les parties partagent une mÃªme rÃ©fÃ©rence de masse et de tension, indispensable pour une mesure fiable.</p>

<h2 id="42-microcontrÃ´leur-arduino">4.2 MicrocontrÃ´leur (Arduino)</h2>

<p>Lâ€™Arduino Uno joue trois rÃ´les :</p>
<ul>
  <li><strong>MaÃ®tre IÂ²C :</strong> il envoie les ordres de lecture au MPU-6050 et rÃ©cupÃ¨re les donnÃ©es brutes.</li>
  <li><strong>Traitement :</strong> il convertit, filtre et fusionne ces mesures, dÃ©tecte le type de mouvement et calcule le Jerk.</li>
  <li><strong>Interface :</strong> il pilote lâ€™Ã©cran LCD pour afficher en temps rÃ©el le rÃ©sultat, et communique sur le port sÃ©rie pour le debug.</li>
</ul>

<h2 id="43-capteur-mpu-6050">4.3 Capteur MPU-6050</h2>

<p>Le MPU-6050 est lâ€™Ã©lÃ©ment source de donnÃ©es :</p>
<ul>
  <li>Il mesure en continu Ã  la frÃ©quence configurÃ©e (ex. 100 Hz).</li>
  <li>Il stocke ces mesures dans ses registres internes, accessibles en IÂ²C.</li>
  <li>Il peut appliquer un DLPF et mÃªme un DMP pour fournir directement des angles fusionnÃ©s.</li>
</ul>

<h2 id="44-affichage-et-debug">4.4 Affichage et debug</h2>

<h3 id="Ã©cran-lcd-162-">Ã‰cran LCD 16Ã—2 :</h3>
<ul>
  <li><strong>Ligne 1 :</strong> indique le type de mouvement (MONTEE, VIRAGEâ€¦, VOL STABLE).</li>
  <li><strong>Ligne 2 :</strong> affiche deux nombres, le score de Jerk et lâ€™accÃ©lÃ©ration totale (en m/sÂ²).</li>
</ul>

<h3 id="moniteur-sÃ©rie-usb-">Moniteur sÃ©rie (USB) :</h3>
<ul>
  <li>Une sortie textuelle dÃ©taillÃ©e permet de suivre en direct les angles, vitesses et valeurs brutes, trÃ¨s utile en phase de test.</li>
</ul>

<h2 id="45-flux-de-donnÃ©es">4.5 Flux de donnÃ©es</h2>

<ul>
  <li><strong>Lecture</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">getMotion6()</code> â†’ rÃ©cupÃ¨re ax, ay, az, gx, gy, gz</li>
    </ul>
  </li>
  <li><strong>Calibration</strong>
    <ul>
      <li>Soustraction des offsets (biais) du gyroscope</li>
      <li>RÃ©fÃ©rence de lâ€™accÃ©lÃ©romÃ¨tre au repos</li>
    </ul>
  </li>
  <li><strong>Conversion</strong>
    <ul>
      <li>LSB â†’ g, LSB â†’ Â°/s</li>
      <li>g â†’ m/sÂ²</li>
    </ul>
  </li>
  <li><strong>Filtrage &amp; fusion</strong>
    <ul>
      <li>DLPF matÃ©riel â†’ moins de bruit</li>
      <li>Filtre complÃ©mentaire logiciel â†’ angle stable</li>
    </ul>
  </li>
  <li><strong>DÃ©tection</strong>
    <ul>
      <li>Classification du mouvement par seuils</li>
      <li>Calcul du Jerk (variation dâ€™accÃ©lÃ©ration)</li>
    </ul>
  </li>
  <li><strong>Affichage</strong>
    <ul>
      <li>LCD et moniteur sÃ©rie</li>
    </ul>
  </li>
</ul>

<p>Chaque Ã©tape sâ€™enchaÃ®ne dans la boucle principale (<code class="language-plaintext highlighter-rouge">loop()</code>), produisant un systÃ¨me fluide et rÃ©actif, prÃªt pour la dÃ©monstration.</p>

<hr />

<h1 id="5-schÃ©ma-Ã©lectrique-kicad">5. SchÃ©ma Ã‰lectrique (KiCad)</h1>

<p>Pour garantir la clartÃ© et la reproductibilitÃ© de notre montage, nous avons rÃ©alisÃ© un schÃ©ma dans KiCad 7.0. Ci-dessous le rendu principal, suivi dâ€™une explication progressive.</p>

<ul>
  <li><strong>Figure:</strong> Fig 1 : Schema_Kicad
  <img src="/docs/semaine-1/electronique/images/Kicade-Schema-Official.png" alt="Schema KiCad" /></li>
</ul>

<h2 id="51-description-des-parties-du-schÃ©ma">5.1 Description des parties du schÃ©ma</h2>

<h3 id="bloc-alimentation">Bloc alimentation</h3>
<ul>
  <li>EntrÃ©e : Pile â†’ Arduino.</li>
  <li>Sortie : +5 V de lâ€™Arduino.</li>
</ul>

<h3 id="arduino-uno-1">Arduino Uno</h3>
<ul>
  <li>Broches A4 (SDA) et A5 (SCL) reliÃ©es au MPU-6050.</li>
  <li>Broches D2â€¦D5, D11, D12 reliÃ©es au LCD en mode 4 bits.</li>
  <li>Broches 5 V et GND alimentÃ©es par la pile 9V.</li>
</ul>

<h3 id="module-mpu-6050">Module MPU-6050</h3>
<ul>
  <li>Broche VCC â†’ +5 V, GND â†’ GND.</li>
  <li>Broche AD0 Ã  GND (adresse 0x68).</li>
  <li>Broche INT non utilisÃ©e (NC).</li>
</ul>

<h3 id="Ã©cran-lcd-162">Ã‰cran LCD 16Ã—2</h3>
<ul>
  <li>VSS â†’ GND, VDD â†’ +5 V, VO â†’ curseur 10 kÎ© (pour le contraste).</li>
  <li>RS â†’ D12, E â†’ D11, D4 â†’ D5, D5 â†’ D4, D6 â†’ D3, D7 â†’ D2.</li>
  <li>RW â†’ GND (mode Ã©criture).</li>
</ul>

<h3 id="potentiomÃ¨tre-p1-10-kÏ‰">PotentiomÃ¨tre P1 (10 kÎ©)</h3>
<ul>
  <li>Broche gauche â†’ +5 V, broche droite â†’ GND, curseur â†’ VO du LCD.</li>
</ul>

<h2 id="52-fichiers-kicad">5.2 Fichiers KiCad</h2>

<ul>
  <li>Projet : <code class="language-plaintext highlighter-rouge">Kicad/</code></li>
  <li>Schematic : <code class="language-plaintext highlighter-rouge">Test1_MPU6050_Schema.kicad_sch</code></li>
  <li>Netlist : exportÃ©e pour documentation.</li>
</ul>

<p><strong>Note :</strong> pour voir le projet complet, consultez le dossier <code class="language-plaintext highlighter-rouge">Kicad/</code> sur notre dÃ©pÃ´t GitHub.  Les symboles ont Ã©tÃ© pris dans les librairies officielles de KiCad et adaptÃ©s pour clarifier les noms de broches.</p>

<hr />

<h1 id="6-installation-et-compilation-du-code">6. Installation et compilation du code</h1>

<p>Avant dâ€™uploader notre programme sur lâ€™Arduino, il faut installer les outils et les bibliothÃ¨ques nÃ©cessaires.</p>

<h2 id="61-prÃ©requis-logiciels">6.1 PrÃ©requis logiciels</h2>

<h3 id="arduino-ide-version--1819">Arduino IDE (version â‰¥ 1.8.19)</h3>
<ul>
  <li>TÃ©lÃ©charger et installer depuis : https://www.arduino.cc/en/software</li>
</ul>

<h3 id="bibliothÃ¨ques-arduino">BibliothÃ¨ques Arduino</h3>
<ul>
  <li><strong>I2Cdevlib</strong> (pour I2Cdev.h et MPU6050.h)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cd ~/Arduino/libraries</code></li>
      <li><code class="language-plaintext highlighter-rouge">git clone https://github.com/jrowberg/i2cdevlib.git</code></li>
    </ul>
  </li>
  <li><strong>LiquidCrystal</strong>
    <ul>
      <li>Inclus dâ€™origine dans lâ€™IDE Arduino.</li>
    </ul>
  </li>
</ul>

<h2 id="62-importer-et-compiler">6.2 Importer et compiler</h2>

<ol>
  <li>Lancer lâ€™IDE Arduino.</li>
  <li>Ouvrir <code class="language-plaintext highlighter-rouge">Test1_MPU6050.ino</code> dans le dossier <code class="language-plaintext highlighter-rouge">Arduino/Test1_MPU6050/</code>.</li>
  <li>VÃ©rifier dans le menu <code class="language-plaintext highlighter-rouge">Croquis â†’ Inclure une bibliothÃ¨que</code> que I2Cdevlib et LiquidCrystal apparaissent.</li>
  <li>SÃ©lectionner la carte : <code class="language-plaintext highlighter-rouge">Outils â†’ Type de carte â†’ Arduino Uno</code>.</li>
  <li>SÃ©lectionner le port sÃ©rie correspondant (<code class="language-plaintext highlighter-rouge">COMx</code> sous Windows, <code class="language-plaintext highlighter-rouge">/dev/ttyACM0</code> sous Linux).</li>
  <li>Cliquer sur <code class="language-plaintext highlighter-rouge">TÃ©lÃ©verser</code> (flÃ¨che â†’) pour compiler et envoyer sur la carte.</li>
</ol>

<p>Une fois le tÃ©lÃ©versement rÃ©ussi, lâ€™Ã©cran LCD doit afficher â€œMAQUETTE AVIONâ€ pendant 3 s avant de passer aux mesures en direct.</p>

<hr />

<h1 id="7-explication-dÃ©taillÃ©e-du-code">7. Explication dÃ©taillÃ©e du code</h1>

<p>Nous parcourons le programme en suivant son ordre dâ€™exÃ©cution, en expliquant chaque bloc de maniÃ¨re claire et accessible :</p>

<h2 id="71-en-tÃªte-et-bibliothÃ¨ques">7.1 En-tÃªte et bibliothÃ¨ques</h2>

<p><strong>Objectif :</strong> prÃ©parer les outils logiciels. 
On inclut :</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;Wire.h&gt;</code> pour le bus IÂ²C.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;I2Cdev.h&gt;</code> et <code class="language-plaintext highlighter-rouge">&lt;MPU6050.h&gt;</code> pour piloter le MPU-6050.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;LiquidCrystal.h&gt;</code> pour lâ€™Ã©cran LCD.</li>
</ul>

<h2 id="72-dÃ©claration-des-objets-et-variables-globales">7.2 DÃ©claration des objets et variables globales</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MPU6050 capteurMouvement;</code> et <code class="language-plaintext highlighter-rouge">LiquidCrystal ecran(...)</code> : crÃ©ation des instances pour le capteur et lâ€™Ã©cran.</li>
  <li><strong>Variables de calibration :</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">erreurGyroX/Y/Z</code> pour le biais du gyroscope.</li>
      <li><code class="language-plaintext highlighter-rouge">referenceAccelX/Y</code> pour la rÃ©fÃ©rence de lâ€™accÃ©lÃ©romÃ¨tre au repos.</li>
    </ul>
  </li>
  <li><strong>Constantes de conversion :</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CONVERSION_ACCEL = 16384.0</code> (LSB â†’ g).</li>
      <li><code class="language-plaintext highlighter-rouge">CONVERSION_GYRO = 131.0</code> (LSB â†’ Â°/s).</li>
    </ul>
  </li>
  <li><strong>Filtre :</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">angleRoulis</code> et <code class="language-plaintext highlighter-rouge">angleTangage</code> seront les angles fusionnÃ©s.</li>
      <li><code class="language-plaintext highlighter-rouge">FORCE_FILTRE = 0.94</code> pour combiner 94 % gyroscope, 6 % accÃ©lÃ©ro.</li>
    </ul>
  </li>
  <li>Variables pour le Jerk et les moyennes mobiles (dÃ©tection de glissement).</li>
</ul>

<h2 id="73-calibration--calibrercapteur">7.3 Calibration : <code class="language-plaintext highlighter-rouge">calibrerCapteur()</code></h2>

<ul>
  <li>Accumulation de 1 000 mesures des axes gyro et accel.</li>
  <li>Affichage de points de progression dans le moniteur sÃ©rie.</li>
  <li>Calcul de la moyenne â†’ ces valeurs deviennent :
    <ul>
      <li><code class="language-plaintext highlighter-rouge">erreurGyroX/Y/Z</code> pour corriger chaque lecture gyroscopique.</li>
      <li><code class="language-plaintext highlighter-rouge">referenceAccelX/Y</code> (en g) pour positionner lâ€™accÃ©lÃ©romÃ¨tre au repos.</li>
    </ul>
  </li>
  <li>Initialisation des moyennes mobiles <code class="language-plaintext highlighter-rouge">moyenneAccelX/Y</code> Ã  ces rÃ©fÃ©rences.</li>
</ul>

<h2 id="74-setup">7.4 setup()</h2>

<ul>
  <li>DÃ©marrage du port sÃ©rie (<code class="language-plaintext highlighter-rouge">Serial.begin(9600)</code>) pour le debug.</li>
  <li>Initialisation IÂ²C (<code class="language-plaintext highlighter-rouge">Wire.begin()</code>) et rÃ©veil du capteur (<code class="language-plaintext highlighter-rouge">initialize()</code>).</li>
  <li><strong>VÃ©rification</strong> (<code class="language-plaintext highlighter-rouge">testConnection()</code> sur <code class="language-plaintext highlighter-rouge">WHO_AM_I</code>) :
    <ul>
      <li>Si Ã©chec, message dâ€™erreur sur LCD et console, puis blocage.</li>
    </ul>
  </li>
  <li><strong>Configuration du MPU-6050 :</strong>
    <ul>
      <li>Plage Â±2 g, Â±250 Â°/s.</li>
      <li>Filtre passe-bas (DLPF) Ã  20 Hz pour rÃ©duire le bruit.</li>
    </ul>
  </li>
  <li>Calibration du capteur (appel Ã  <code class="language-plaintext highlighter-rouge">calibrerCapteur(1000)</code>).</li>
  <li>Message dâ€™accueil sur lâ€™Ã©cran LCD (â€œMAQUETTE AVION / PRET AU VOLâ€), puis pause de 3 s.</li>
  <li>Initialisation du chronomÃ¨tre (<code class="language-plaintext highlighter-rouge">dernierTemps = millis()</code>).</li>
</ul>

<h2 id="75-boucle-principale--loop">7.5 Boucle principale : loop()</h2>

<p>Chaque cycle dure 100 ms (~10 Hz) :</p>
<ul>
  <li><strong>Lecture brutes</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">capteurMouvement</span><span class="p">.</span><span class="n">getMotion6</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ax</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ay</span><span class="p">,</span><span class="o">&amp;</span><span class="n">az</span><span class="p">,</span><span class="o">&amp;</span><span class="n">gx</span><span class="p">,</span><span class="o">&amp;</span><span class="n">gy</span><span class="p">,</span><span class="o">&amp;</span><span class="n">gz</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Temps Ã©coulÃ©</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">float</span> <span class="n">deltaTemps</span> <span class="o">=</span> <span class="p">(</span><span class="n">millis</span><span class="p">()</span> <span class="o">-</span> <span class="n">dernierTemps</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">;</span>
  <span class="n">dernierTemps</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Correction &amp; conversion</strong>
    <ul>
      <li>Gyro corrigÃ© en Â°/s : <code class="language-plaintext highlighter-rouge">(gx - erreurGyroX) / CONVERSION_GYRO</code>.</li>
      <li>AccÃ©lÃ©ration en g : <code class="language-plaintext highlighter-rouge">ax / CONVERSION_ACCEL</code>.</li>
    </ul>
  </li>
  <li><strong>Moyennes mobiles pour glissement :</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">moyenneAccelX</span> <span class="o">=</span> <span class="mf">0.95</span><span class="o">*</span><span class="n">moyenneAccelX</span> <span class="o">+</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">aX</span><span class="p">;</span>
  <span class="n">moyenneAccelY</span> <span class="o">=</span> <span class="mf">0.95</span><span class="o">*</span><span class="n">moyenneAccelY</span> <span class="o">+</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">aY</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Fusion capteurs (filtre complÃ©mentaire) :</strong>
    <ul>
      <li>Calcul des angles accel par <code class="language-plaintext highlighter-rouge">atan2()</code>.</li>
      <li>IntÃ©gration du gyro (<code class="language-plaintext highlighter-rouge">angle += vitesse * dt</code>).</li>
      <li>MÃ©lange : <code class="language-plaintext highlighter-rouge">angle = Î±*angleGyro + (1â€“Î±)*angleAccel</code>.</li>
    </ul>
  </li>
  <li><strong>DÃ©tection de type de mouvement</strong>
    <ul>
      <li>PrioritÃ© 1 : inclinaison (roll/pitch &gt; Â±12Â°) â†’ â€œMONTEEâ€, â€œDESCENTEâ€, â€œVIRAGEâ€¦â€.</li>
      <li>PrioritÃ© 2 : lacet (vitesseZ &gt; 45Â°/s) â†’ â€œROTATIONâ€.</li>
      <li>PrioritÃ© 3 : glissement avant/arriÃ¨re (diffX &gt; 0,15 g) â†’ â€œAVANCEâ€/â€RECULEâ€.</li>
      <li>PrioritÃ© 4 : glissement latÃ©ral (diffY &gt; 0,15 g) â†’ â€œGLISSEâ€¦â€.</li>
      <li>Sinon : â€œVOL STABLEâ€ aprÃ¨s 5 cycles de stabilitÃ©.</li>
    </ul>
  </li>
  <li><strong>Calcul du Jerk</strong>
    <ul>
      <li>AccÃ©lÃ©ration totale en m/sÂ² : <code class="language-plaintext highlighter-rouge">sqrt(aXÂ² + aYÂ² + aZÂ²) * 9.81</code>.</li>
      <li>DiffÃ©rence avec la mesure prÃ©cÃ©dente â†’ lissage exponentiel pour <code class="language-plaintext highlighter-rouge">scoreJerk</code>.</li>
    </ul>
  </li>
  <li><strong>Affichage sur LCD</strong>
    <ul>
      <li>Ligne 1 : <code class="language-plaintext highlighter-rouge">mouvementDetecte</code>.</li>
      <li>Ligne 2 : <code class="language-plaintext highlighter-rouge">J:â€¦ A:â€¦ m/s2</code>, avec effacement des caractÃ¨res rÃ©siduels.</li>
    </ul>
  </li>
  <li><strong>Debug sÃ©rie</strong>
    <ul>
      <li>Envoi des valeurs (angles, vitesses, accÃ©lÃ©rations, Jerk) sur le moniteur.</li>
    </ul>
  </li>
</ul>

<h2 id="76-fonctions-utilitaires">7.6 Fonctions utilitaires</h2>

<h3 id="remettreazero-">remettreAZero() :</h3>
<ul>
  <li>RÃ©initialise <code class="language-plaintext highlighter-rouge">angleRoulis</code>, <code class="language-plaintext highlighter-rouge">angleTangage</code>, <code class="language-plaintext highlighter-rouge">scoreJerk</code>, <code class="language-plaintext highlighter-rouge">moyenneAccelX/Y</code>.</li>
  <li>Affiche â€œREMISE A ZEROâ€ sur le LCD pour 2 s.</li>
</ul>

<hr />

<h1 id="8-mode-demploi-et-dÃ©monstration">8. Mode dâ€™emploi et dÃ©monstration</h1>

<h2 id="81-mise-sous-tension">8.1 Mise sous tension</h2>

<ol>
  <li>Pile 9v â†’ Arduino Uno</li>
  <li>Connecter lâ€™Arduino via USB pour le debug (facultatif).</li>
  <li>Allumer lâ€™interrupteur (si prÃ©sent).</li>
</ol>

<h2 id="82-dÃ©roulÃ©-de-la-sÃ©quence">8.2 DÃ©roulÃ© de la sÃ©quence</h2>

<ol>
  <li>Ã€ lâ€™allumage, le LCD affiche â€œMAQUETTE AVION / PRET AU VOLâ€ (3 s).</li>
  <li>Le systÃ¨me entre en mode mesure :
    <ul>
      <li>LCD ligne 1 : type de mouvement dÃ©tectÃ© (MONTEE, VIRAGEâ€¦, VOL STABLE).</li>
      <li>LCD ligne 2 : J:score Jerk A:accÃ©lÃ©ration m/sÂ².</li>
    </ul>
  </li>
  <li>ManÅ“uvres Ã  tester :
    <ul>
      <li>Inclinaison lente â†’ â€œMONTEEâ€ ou â€œDESCENTEâ€.</li>
      <li>Virage (basculer gauche/droite) â†’ â€œVIRAGE GAUCHE/DROITEâ€.</li>
      <li>Glissement sur la table â†’ â€œAVANCEâ€, â€œRECULEâ€, â€œGLISSEâ€¦â€.</li>
      <li>Rotation rapide â†’ â€œROTATION Gâ€ ou â€œROTATION Dâ€.</li>
      <li>Pas de mouvement â†’ â€œVOL STABLEâ€ aprÃ¨s 0,5 s.</li>
    </ul>
  </li>
</ol>

<h2 id="83-utilisation-du-moniteur-sÃ©rie">8.3 Utilisation du moniteur sÃ©rie</h2>

<ul>
  <li>9600 bauds.</li>
  <li>Affiche en continu :
    <ul>
      <li><code class="language-plaintext highlighter-rouge">MONTEE | R:â€¦ T:â€¦ | Lacet:â€¦ |</code></li>
      <li><code class="language-plaintext highlighter-rouge">AX:â€¦ DX:â€¦ AY:â€¦ DY:â€¦ | Jerk:â€¦</code></li>
    </ul>
  </li>
</ul>

<p><strong>VidÃ©o de dÃ©monstration :</strong>
Vous pouvez visionner une dÃ©monstration de notre systÃ¨me en action ci-dessous :</p>

<p><a href="https://vimeo.com/manage/videos/1092850492">VidÃ©o demo 1</a></p>

<p><a href="https://vimeo.com/manage/videos/1092852315/a32b8a9039">Video demo 2</a></p>

<hr />

<h1 id="9-rÃ©sultats-attendus">9. RÃ©sultats attendus</h1>

<p>Pour valider le test, voici trois scÃ©narios typiques avec captures dâ€™Ã©cran simulÃ©es :</p>

<table>
  <thead>
    <tr>
      <th>ScÃ©nario</th>
      <th>LCD Ligne 1</th>
      <th>LCD Ligne 2</th>
      <th>Moniteur sÃ©rie extrait</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Inclinaison vers lâ€™avant</td>
      <td>MONTEE</td>
      <td>J: 5 A: 11.3 m/sÂ²</td>
      <td><code class="language-plaintext highlighter-rouge">MONTEE</code></td>
    </tr>
    <tr>
      <td>Virage Ã  droite</td>
      <td>VIRAGE DROITE</td>
      <td>J:â€‰3 A:â€‰9.5â€‰m/sÂ²</td>
      <td><code class="language-plaintext highlighter-rouge">VIRAGE DROITE</code></td>
    </tr>
    <tr>
      <td>Glissement latÃ©ral</td>
      <td>GLISSE DROITE</td>
      <td>J:â€‰2 A:â€‰9.9â€‰m/sÂ²</td>
      <td><code class="language-plaintext highlighter-rouge">GLISSE DROITE</code></td>
    </tr>
    <tr>
      <td>Repos</td>
      <td>VOL STABLE</td>
      <td>J: 0 A: 9.81 m/sÂ²</td>
      <td><code class="language-plaintext highlighter-rouge">VOL STABLE</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Remarque :</strong></p>
<ul>
  <li>Les valeurs de Jerk varient selon la brutalitÃ© du mouvement (plus le pic est Ã©levÃ©, plus la manÅ“uvre a Ã©tÃ© soudaine).</li>
  <li>Lâ€™accÃ©lÃ©ration en m/sÂ² se stabilise autour de 9,81 m/sÂ² au repos (1 g).</li>
</ul>

<hr />

<h1 id="10-conseils-de-rÃ©glage-et-calibration">10. Conseils de rÃ©glage et calibration</h1>

<p>Afin dâ€™optimiser la prÃ©cision et la stabilitÃ© de votre systÃ¨me, voici quelques bonnes pratiques et ajustements possibles :</p>

<h2 id="101-refaire-la-calibration-selon-lenvironnement">10.1 Refaire la calibration selon lâ€™environnement</h2>

<ul>
  <li><strong>Surface stable et horizontale</strong>: Toujours placer le capteur immobile sur une surface parfaitement plane et sans vibrations pendant la calibration.</li>
  <li><strong>Nombre dâ€™Ã©chantillons</strong>: Par dÃ©faut nous prenons 1 000 mesures (â‰ˆ 10 s). Vous pouvez augmenter ce nombre (ex. 2 000) pour affiner le biais du gyroscope au prix dâ€™un temps de calibration plus long.</li>
  <li><strong>TempÃ©rature</strong>: Les caractÃ©ristiques MEMS varient lÃ©gÃ¨rement avec la tempÃ©rature. Si votre environnement change beaucoup (extÃ©rieur vs intÃ©rieur), rÃ©alisez une nouvelle calibration.</li>
</ul>

<h2 id="102-ajuster-les-seuils-de-dÃ©tection">10.2 Ajuster les seuils de dÃ©tection</h2>

<p>Les seuils dÃ©finissent quand le programme passe dâ€™un mouvement Ã  un autre :</p>

<table>
  <thead>
    <tr>
      <th>Seuil actuel</th>
      <th>Usage</th>
      <th>Ajustement possible</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Â±12Â°</td>
      <td>DÃ©tecter roulis/tangage</td>
      <td>+/â€“ 8Â° pour plus de sensibilitÃ©</td>
    </tr>
    <tr>
      <td>45 Â°/s</td>
      <td>DÃ©tecter lacet</td>
      <td>60 Â°/s si rotations plus rapides</td>
    </tr>
    <tr>
      <td>0,15 g</td>
      <td>Glissements avant/arriÃ¨re</td>
      <td>0,10 g pour capter de plus faibles dÃ©placements</td>
    </tr>
  </tbody>
</table>

<p><strong>Astuce :</strong> testez chaque seuil avec des mouvements lents puis rapides et observez le comportement sur le moniteur sÃ©rie avant de modifier le code.</p>

<h2 id="103-rÃ©gler-le-filtre-passe-bas-dlpf">10.3 RÃ©gler le filtre passe-bas (DLPF)</h2>

<ul>
  <li><strong>DLPF Ã  20 Hz</strong> (configuration actuelle) [cite: 121]: supprime la majoritÃ© du bruit haute frÃ©quence, recommandÃ© pour un robot lent ou une maquette.</li>
  <li><strong>DLPF Ã  42 Hz ou 98 Hz</strong> [cite: 122]: plus rÃ©actif aux mouvements rapides, au prix dâ€™un peu plus de bruit.</li>
  <li>Modifier la ligne :
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">capteurMouvement</span><span class="p">.</span><span class="n">setDLPFMode</span><span class="p">(</span><span class="n">MPU6050_DLPF_BW_42</span><span class="p">);</span>
</code></pre></div>    </div>
    <p>dans <code class="language-plaintext highlighter-rouge">setup()</code> pour tester diffÃ©rentes frÃ©quences.</p>
  </li>
</ul>

<h2 id="104-filtre-complÃ©mentaire-vs-dmp">10.4 Filtre complÃ©mentaire vs DMP</h2>

<h3 id="filtre-logiciel-complÃ©mentaire">Filtre logiciel (complÃ©mentaire)</h3>
<ul>
  <li>RÃ©glage du coefficient Î± (0,94) [cite: 125]: ajustez-le vers 0,98 pour plus de stabilitÃ© long terme ou 0,90 pour plus de rÃ©activitÃ©.</li>
</ul>

<h3 id="dmp-interne">DMP interne</h3>
<ul>
  <li>Charge le microcode dans le MPU-6050 et laisse le DMP fusionner accÃ©lÃ©ro+gyro automatiquement.</li>
  <li><strong>Avantage</strong> [cite: 127]: rÃ©sultats dÃ©jÃ  filtrÃ©s, moins de code sur lâ€™Arduino.</li>
  <li><strong>InconvÃ©nient</strong> [cite: 128]: setup plus complexe (chargement de firmwares) et moins de contrÃ´le direct.</li>
</ul>

<hr />

<h1 id="11-limitations-et-pistes-damÃ©lioration">11. Limitations et pistes dâ€™amÃ©lioration</h1>

<p>MÃªme si notre solution rÃ©pond au Test 1, voici quelques points Ã  considÃ©rer pour aller plus loin :</p>

<h2 id="111-limitations-actuelles">11.1 Limitations actuelles</h2>

<ul>
  <li><strong>Utilisation de String Arduino</strong>: Peut fragmenter la mÃ©moire dynamique (heap) sur le long terme, provoquant des plantages.</li>
  <li><strong>Affichage LCD limitÃ©</strong>: Le HD44780 est lent (quelques millisecondes par print), donc frÃ©quence dâ€™affichage limitÃ©e Ã  ~10 Hz.</li>
  <li><strong>Pas dâ€™interruption IÂ²C / DMP</strong>: Lecture pÃ©riodique via <code class="language-plaintext highlighter-rouge">delay()</code> ; pas dâ€™usage des interruptions MPU-6050 ou du DMP pour des mesures plus rapides et efficaces.</li>
  <li><strong>Montage sur breadboard</strong>: Sensible aux faux contacts et au bruit Ã©lectrique, surtout sur IÂ²C.</li>
</ul>

<h2 id="112-pistes-damÃ©lioration">11.2 Pistes dâ€™amÃ©lioration</h2>

<ul>
  <li><strong>Passer Ã  <code class="language-plaintext highlighter-rouge">char[]</code> plutÃ´t quâ€™Ã  String</strong>: Utiliser <code class="language-plaintext highlighter-rouge">snprintf()</code> pour formater les chaÃ®nes sans fragments mÃ©moire.</li>
  <li><strong>Utiliser le DMP</strong>: Charger le microcode, lire les quaternions directement, et en dÃ©duire les angles sans filtre logiciel.</li>
  <li><strong>Optimiser lâ€™affichage</strong>: Mettre Ã  jour lâ€™Ã©cran LCD seulement quand lâ€™affichage change rÃ©ellement (comparer lâ€™ancienne et la nouvelle ligne).</li>
  <li><strong>Passer Ã  un afficheur plus rapide (OLED IÂ²C)</strong>  pour des taux de rafraÃ®chissement plus Ã©levÃ©s.</li>
  <li><strong>Enregistrer les donnÃ©es</strong>: Ajouter un module carte SD pour logger les valeurs brutes ou filtrÃ©es, utile pour lâ€™analyse post-test.</li>
  <li><strong>Utiliser des interruptions</strong>: Configurer lâ€™INT du MPU-6050 pour dÃ©clencher une interruption sur lâ€™Arduino dÃ¨s quâ€™une nouvelle mesure est prÃªte, et traiter sans <code class="language-plaintext highlighter-rouge">delay()</code>.</li>
  <li><strong>Conception PCB</strong>: Remplacer la breadboard par un circuit imprimÃ© (PCB) pour fiabilitÃ© Ã©lectrique et mÃ©canique.</li>
</ul>

<hr />

<h1 id="12-rÃ©fÃ©rences-et-annexes">12. RÃ©fÃ©rences et annexes</h1>

<h2 id="121-rÃ©fÃ©rences">12.1 RÃ©fÃ©rences</h2>

<ul>
  <li><strong>MPU-6050 (InvenSense)</strong>
    <ul>
      <li>â€œInvenSense, Â« MPU-6000 and MPU-6050 Product Specification Revision 3.4 Â», 2013â€</li>
      <li><a href="https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf">https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf</a></li>
    </ul>
  </li>
  <li><strong>Documentation I2Cdevlib</strong>
    <ul>
      <li>â€œJeff Rowberg, Â« i2cdevlib/MPU6050 Â», GitHubâ€</li>
      <li><a href="https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/MPU6050">https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/MPU6050</a></li>
    </ul>
  </li>
  <li><strong>LiquidCrystal (HD44780)</strong>
    <ul>
      <li>â€œArduino, Â« LiquidCrystal Library Reference Â»â€</li>
      <li><a href="https://www.arduino.cc/en/Reference/LiquidCrystal">https://www.arduino.cc/en/Reference/LiquidCrystal</a></li>
    </ul>
  </li>
  <li><strong>KiCad EDA</strong>
    <ul>
      <li>â€œKiCad Developers, Â« KiCad Schematic and PCB CAD Â»â€</li>
      <li><a href="https://www.kicad.org/">https://www.kicad.org/</a></li>
    </ul>
  </li>
  <li><strong>Arduino IDE</strong>
    <ul>
      <li>â€œArduino, Â« Download the Arduino IDE Â»â€</li>
      <li><a href="https://www.arduino.cc/en/software">https://www.arduino.cc/en/software</a></li>
    </ul>
  </li>
  <li><strong>RÃ©gulateur 7805</strong>
    <ul>
      <li>â€œON Semiconductor, Â« LM7805 Series Positive Voltage Regulator Â»â€</li>
      <li><a href="https://www.onsemi.com/pdf/datasheet/lm7805-d.pdf">https://www.onsemi.com/pdf/datasheet/lm7805-d.pdf</a></li>
    </ul>
  </li>
</ul>

<h2 id="122-annexes">12.2 Annexes</h2>

<h3 id="a-code-source-complet">A. Code source complet</h3>
<p>Le code complet est disponible dans le fichier <code class="language-plaintext highlighter-rouge">Test1_MPU6050.ino</code> de notre dÃ©pÃ´t GitHub :
<a href="https://github.com/votre-equipe/tekbot-trc2025/blob/main/Test1/Test1_MPU6050.ino">https://github.com/votre-equipe/tekbot-trc2025/blob/main/Test1/Test1_MPU6050.ino</a></p>

<h3 id="b-fichiers-kicad">B. Fichiers KiCad</h3>
<ul>
  <li><strong>SchÃ©ma :</strong> <code class="language-plaintext highlighter-rouge">Kicad/Test1_MPU6050_Schema.kicad_sch</code></li>
</ul>

<h3 id="c-glossaire">C. Glossaire</h3>

<p>| Terme | DÃ©finition                                                              |
|â€”â€”-|â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-|
| LSB   | Least Significant Bit, unitÃ© numÃ©rique Ã©lÃ©mentaire des convertisseurs. |
| DLPF  | Digital Low Pass Filter, filtre numÃ©rique passe-bas intÃ©grÃ© au capteur. |
| DMP   | Digital Motion Processor, coprocesseur interne du MPU pour fusion de donnÃ©es. |
| Jerk  | Variation de lâ€™accÃ©lÃ©ration, mesurÃ©e en m/sÂ³ (ici simplifiÃ©e en score arbitraire). |
â€”</p>

<p><strong>Fin de la documentation du Test 1 Electronique â€“ Tekbot Robotics Challenge 2025</strong></p>

      </div>
    </div>
  </div>

  <!-- Footer en dehors de la structure sidebar/main-content -->
  <footer class="site-footer">
    <div class="container">
      <p>&copy; 2025 Documentation Ã‰quipe IFRI 2025. Tous droits rÃ©servÃ©s.</p>
    </div>
  </footer>

  <script src="/assets/js/main.js"></script>
</body>
</html>
</html>
